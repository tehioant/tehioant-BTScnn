# Written by: Erick Cobos T. (a01184587@itesm.mx)
# Date: August 2016

""" Quick script to eval images using a trained network
Example:
	>>> import eval
	>>> iou, prediction, segmentation = eval.evaluate("my_image.png", "my_label.png")

Note:
	Call tf.reset_default_graph() to run it twice in the same python terminal.
	Otherwise, restore will not work.
"""
import tensorflow as tf
import scipy.misc
import numpy as np
import matplotlib.pyplot as plt

# Import network definition
import model_v3 as model

# Set some parameters
MODEL_DIR = "run1"
THRESHOLD_PROB = 0.5 # to produce the final segmentation
CMAP_NAME = 'nipy_spectral' # colormap to use to print the logit map

def load_image(image_path):
	""" Load png image as tensor and whiten it."""
	image_content = tf.read_file(image_path)
	image = tf.image.decode_png(image_content)
	whitened_image = tf.image.per_image_whitening(image)
	return whitened_image
	
def post(logits, label, threshold):
	"""Creates segmentation assigning everything over the threshold a value of 
	255, anythig equals to background in label as 0 and anythign else 127. 
	
	Using the label may seem like cheating but the background part of the label 
	was generated by thresholding the original image to zero, so it is as if i
	did that here. Just that it is more cumbersome. Not that important either as
	I calculate IOU for massses and not for backgorund or breats tissue."""
	thresholded = np.ones(logits.shape, dtype='uint8') * 127
	thresholded[logits >= threshold] = 255
	thresholded[label == 0] = 0
	return thresholded
	
def IOU(segmentation, label):
	"""Intersection over union"""
	intersection = np.logical_and(segmentation == 255, label == 255)
	union = np.logical_or(segmentation == 255, label == 255)
	iou = np.sum(intersection)/np.sum(union)
	return iou
	
def evaluate(image_path, label_path, threshold_prob=THRESHOLD_PROB, 
			 model_dir=MODEL_DIR):
	""" Loads network, reads images, saves prediction and segmentation as .png
		and reports IOU."""
	# Calculate threshold as logit	
	threshold = np.log(threshold_prob) - np.log(1 - threshold_prob)
	
	# Load image and label
	image = load_image(image_path)
	label = scipy.misc.imread(label_path)
	
	# Define the model
	prediction = model.forward(image, drop=tf.constant(False))
	
	# Get a saver
	saver = tf.train.Saver()

	# Use CPU-only. To enable GPU, delete this and call with tf.Session() as ...
	config = tf.ConfigProto(device_count={'GPU':0})
	
	# Launch graph
	with tf.Session(config=config) as sess:
		# Restore variables
		checkpoint_path = tf.train.latest_checkpoint(model_dir)
		print("Restoring model from:", checkpoint_path)
		saver.restore(sess, checkpoint_path)
	
		logits = prediction.eval()
		plt.imsave("logits.png", logits, cmap=plt.get_cmap(CMAP_NAME))
		
		probs = 1/(1 + np.exp(-logits))
		plt.imsave("probs.png", probs, cmap=plt.get_cmap(CMAP_NAME))
		
		segmentation = post(logits, label, threshold)
		scipy.misc.imsave("segmentation.png", segmentation)
		
		iou = IOU(segmentation, label)
		print("iou =", iou)
		
	return iou, logits, segmentation
